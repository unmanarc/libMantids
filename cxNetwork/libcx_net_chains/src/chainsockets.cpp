#include "chainsockets.h"
#include <thread>

void chainThread(sChainTElement * chain)
{
    char data[4096];
    int r0;
    bool w1=0;

    while (     (r0=chain->sockets[0]->partialRead(data,sizeof(data)))>0 &&
                ((w1=chain->sockets[1]->writeBlock(data,r0)))==true )
    {
    }

    // Write result values
    *(chain->r0) = r0;
    *(chain->w1) = w1;

    // TODO: call ending phase functions for stream sockets...

    // Shutdown sockets...
    chain->sockets[0]->shutdownSocket(SHUT_RD);
    chain->sockets[1]->shutdownSocket(SHUT_WR);

    delete chain;
}

ChainSockets::ChainSockets(Socket_Base_Stream *_baseSocket, bool _deleteBaseSocketOnExit)
{
    endPointReached = false;
    deleteBaseSocketOnExit = _deleteBaseSocketOnExit;
    baseSocket = _baseSocket;
}


void ChainSockets::waitUntilFinish()
{
    for (sChainVectorItem * sockItem : socketLayers)
    {
        if (!sockItem->detached)
        {
            sockItem->thr1.join();
            sockItem->thr2.join();

            sockItem->detached = true;
            sockItem->finished = true;
        }
    }
}

void ChainSockets::removeSocketsOnExit()
{
    for (sChainVectorItem * sockItem : socketLayers)
    {
        if (sockItem->deleteFirstSocketOnExit)
        {
            delete sockItem->sock[0];
            sockItem->sock[0] = nullptr;
        }
        if (sockItem->deleteSecondSocketOnExit)
        {
            delete sockItem->sock[1];
            sockItem->sock[1] = nullptr;
        }
    }
}

ChainSockets::~ChainSockets()
{
    // Propagate the shutdownSocket
    shutdownSocket();

    // Wait for threads:
    waitUntilFinish();

    // Delete if needed.
    removeSocketsOnExit();

    // Remove items when all threads are down.
    for (sChainVectorItem * sockItem : socketLayers)
    {
        delete sockItem;
    }
    socketLayers.clear();

    // delete the base socket if needed.
    if (deleteBaseSocketOnExit) delete baseSocket;
}


size_t ChainSockets::getLayers()
{
    return socketLayers.size();
}

int ChainSockets::getLayerReadResultValue(size_t layer, bool fwd)
{
    if (layer>=socketLayers.size()) return -2;
    // TODO: check this.
    return ((sChainVectorItem *)socketLayers[layer])->r0[fwd?0:1];
}

bool ChainSockets::getLayerWriteResultValue(size_t layer, bool fwd)
{
    if (layer>=socketLayers.size()) return false;
    // TODO: check this.
    return ((sChainVectorItem *)socketLayers[layer])->w1[fwd?0:1];
}

std::pair<Socket_Base_Stream *, Socket_Base_Stream *> ChainSockets::getSocketPairLayer(size_t layer)
{
    std::pair <Socket_Base_Stream *, Socket_Base_Stream *> bar;

    if (layer>=socketLayers.size())
        return std::make_pair (nullptr,nullptr);

    return std::make_pair (((sChainVectorItem *)socketLayers[layer])->sock[0],((sChainVectorItem *)socketLayers[layer])->sock[1]);
}

bool ChainSockets::addToChain(SocketChainBase *chainElement)
{
    return addToChain( chainElement->makeSocketChainPair(),
                             false, // First socket wont be deleted because it's SocketChainXOR (use false here) // TODO: check this
                             true, // Second socket is generated by makeSocketChainPair, should be automatically deleted.
                             chainElement->isServerMode(), // Server mode: true
                             false, // Detached is false (should wait until finalization when deleting ChainSockets...)
                             chainElement->isEndPoint()
                             );
}

bool ChainSockets::addToChain(std::pair<Socket_Base_Stream *, Socket_Base_Stream *> sockPairs, bool deleteFirstSocketOnExit, bool deleteSecondSocketOnExit, bool modeServer, bool detached, bool endPMode)
{
    if (endPointReached) return false;
    if (endPMode) endPointReached = true;

    sChainVectorItem * item = new sChainVectorItem;

    // Register on chain
    item->deleteFirstSocketOnExit = deleteFirstSocketOnExit;
    item->deleteSecondSocketOnExit = deleteSecondSocketOnExit;
    item->sock[0] = sockPairs.first;
    item->sock[1] = sockPairs.second;
    item->modeServer = modeServer;
    socketLayers.push_back(item);

    // Register on thread.
    sChainTElement * chainTElem1 = new sChainTElement;
    sChainTElement * chainTElem2 = new sChainTElement;

    chainTElem1->sockets[0] = item->sock[1];
    chainTElem1->sockets[1] = socketLayers.size()==1? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-2])->sock[0];
    chainTElem1->modeFWD = true;
    chainTElem1->r0 = &(item->r0[0]);
    chainTElem1->w1 = &(item->w1[0]);

    chainTElem2->sockets[0] = chainTElem1->sockets[1];
    chainTElem2->sockets[1] = chainTElem1->sockets[0];
    chainTElem2->modeFWD = false;
    chainTElem2->r0 = &(item->r0[1]);
    chainTElem2->w1 = &(item->w1[1]);

    item->thr1 = std::thread(chainThread, chainTElem1);
    item->thr2 = std::thread(chainThread, chainTElem2);

    if (detached)
    {
        item->detached = true;
        item->thr1.detach();
        item->thr2.detach();
    }

    ///////////////////////////////////
    // Now we init this socket...
    bool r;
    if (modeServer)
        r = sockPairs.first->postAcceptSubInitialization();
    else
        r = sockPairs.first->postConnectSubInitialization();

    if (!r)
    {
        item->sock[0]->shutdownSocket();
        item->sock[1]->shutdownSocket();
    }

    return r;
}

int ChainSockets::shutdownSocket(int mode)
{
    if (socketLayers.size() == 0 && !baseSocket) return -1;
    Socket_Base_Stream * curSocket = !socketLayers.size()? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-1])->sock[0];
    return curSocket->shutdownSocket(mode);
}

int ChainSockets::partialRead(void *data, uint32_t datalen)
{
    if (socketLayers.size() == 0 && !baseSocket) return -1;
    Socket_Base_Stream * curSocket = !socketLayers.size()? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-1])->sock[0];
    return curSocket->partialRead(data,datalen);
}

int ChainSockets::partialWrite(void *data, uint32_t datalen)
{
    if (socketLayers.size() == 0 && !baseSocket) return -1;
    Socket_Base_Stream * curSocket = !socketLayers.size()? baseSocket : ((sChainVectorItem *)socketLayers[socketLayers.size()-1])->sock[0];
    return curSocket->partialWrite(data,datalen);
}
