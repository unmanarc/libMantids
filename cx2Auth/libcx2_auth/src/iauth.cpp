#include "iauth.h"

#include <cx2_thr_mutex/lock_shared.h>
#include <cx2_hlp_functions/random.h>

using namespace CX2::Authorization;
using namespace CX2::Authorization::DataStructs;

IAuth::IAuth()
{
}

IAuth::~IAuth()
{
}

bool IAuth::initAccounts()
{
    // create the default account.
    sPasswordData passData;
    passData.forceExpiration = true;
    passData.hash = CX2::Helpers::Random::createRandomString(16);

    return accountAdd("admin",  // UserName
                      passData, // Password Info
                      "", // Email
                      "Autogenerated Superuser Account", // Account Description
                      "",  // Extra Data
                      0, // Expiration (don't expire)
                      true, // enabled
                      true, // confirmed
                      true // superuser
                      );
}

AuthReason IAuth::authenticate(const std::string &accountName, const std::string &password, uint32_t passIndex, AuthMode authMode, const std::string &cramSalt)
{
    AuthReason ret;
    bool found=false;
    Threads::Sync::Lock_RD lock(mutex);
    sPasswordData pData = retrievePassword(accountName,passIndex, &found);
    if (found)
    {
        if (!isAccountConfirmed(accountName)) ret = AUTH_REASON_UNCONFIRMED_ACCOUNT;
        else if (isAccountDisabled(accountName)) ret = AUTH_REASON_DISABLED_ACCOUNT;
        else if (isAccountExpired(accountName)) ret = AUTH_REASON_EXPIRED_ACCOUNT;
        else ret = validatePassword(pData, password,  cramSalt, authMode);
    }
    else
        ret = AUTH_REASON_BAD_ACCOUNT;
    return ret;
}

std::string IAuth::genRandomConfirmationToken()
{
    return CX2::Helpers::Random::createRandomString(64);
}

sPasswordBasicData IAuth::accountPasswordBasicData(const std::string &accountName, bool *found, uint32_t passIndex)
{
    // protective-limited method.
    sPasswordData pd = retrievePassword(accountName, passIndex, found);
    sPasswordBasicData pdb;

    if (!*found) pdb.passwordMode = PASS_MODE_NOTFOUND;
    else
    {
        pdb = pd.getBasicData();
    }

    return pdb;
}

bool IAuth::isAccountExpired(const std::string &accountName)
{
    time_t tAccountExpirationDate = accountExpirationDate(accountName);
    if (!tAccountExpirationDate) return false;
    return tAccountExpirationDate<time(nullptr);
}

std::set<std::string> IAuth::accountUsableAttribs(const std::string &accountName)
{
    std::set<std::string> x;
    Threads::Sync::Lock_RD lock(mutex);
    // Take attribs from the account
    for (const std::string & attrib : accountDirectAttribs(accountName,false))
        x.insert(attrib);

    // Take the attribs from the belonging groups
    for (const std::string & groupName : accountGroups(accountName,false))
    {
        for (const std::string & attrib : groupAttribs(groupName,false))
            x.insert(attrib);
    }
    return x;
}

bool IAuth::accountValidateAttribute(const std::string &accountName, const std::string &attribName)
{
    Threads::Sync::Lock_RD lock(mutex);
    if (accountValidateDirectAttribute(accountName,attribName))
    {
        return true;
    }
    for (const std::string & groupName : accountGroups(accountName,false))
    {
        if (groupValidateAttribute(groupName, attribName,false))
        {
            return true;
        }
    }
    return false;
}
