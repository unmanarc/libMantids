#include "manager.h"

#include <cx2_thr_mutex/lock_shared.h>
#include <cx2_hlp_functions/random.h>

using namespace CX2::Authentication;


Manager::Manager()
{
}

Manager::~Manager()
{
}

bool Manager::initAccounts()
{
    // create the default account.
    Secret secretData;
    secretData.forceExpiration = true;
    secretData.hash = CX2::Helpers::Random::createRandomString(16);

    return accountAdd("admin",  // UserName
                      secretData, // Secret Info
                      "", // Email
                      "Autogenerated Superuser Account", // Account Description
                      "",  // Extra Data
                      0, // Expiration (don't expire)
                      true, // enabled
                      true, // confirmed
                      true // superuser
                      );
}

Reason Manager::authenticate(const std::string &sUserName, const std::string &incommingPassword, uint32_t passIndex, Mode authMode, const std::string &challengeSalt)
{
    Reason ret;
    bool found=false;
    Threads::Sync::Lock_RD lock(mutex);
    Secret pStoredSecretData = retrieveSecret(sUserName,passIndex, &found);
    if (found)
    {
        if (!isAccountConfirmed(sUserName)) ret = REASON_UNCONFIRMED_ACCOUNT;
        else if (isAccountDisabled(sUserName)) ret = REASON_DISABLED_ACCOUNT;
        else if (isAccountExpired(sUserName)) ret = REASON_EXPIRED_ACCOUNT;
        else
            ret = validateStoredSecret(pStoredSecretData, incommingPassword, challengeSalt, authMode);
    }
    else
        ret = REASON_BAD_ACCOUNT;
    return ret;
}

std::string Manager::genRandomConfirmationToken()
{
    return CX2::Helpers::Random::createRandomString(64);
}

Secret_PublicData Manager::accountSecretPublicData(const std::string &sUserName, bool *found, uint32_t passIndex)
{
    // protective-limited method.
    Secret pd = retrieveSecret(sUserName, passIndex, found);
    Secret_PublicData pdb;

    if (!*found) pdb.passwordFunction = FN_NOTFOUND;
    else
    {
        pdb = pd.getBasicData();
    }

    return pdb;
}

bool Manager::accountChangeAuthenticatedSecret(const std::string &sUserName, const std::string &currentPassword, Mode authMode, const std::string &challengeSalt, const Secret &passwordData, uint32_t passIndex)
{
    auto i = authenticate(sUserName,currentPassword,passIndex,authMode,challengeSalt);
    if (i!=REASON_AUTHENTICATED && i!=REASON_EXPIRED_PASSWORD)
        return false;
    return accountChangeSecret(sUserName,passwordData,passIndex);
}

bool Manager::isAccountExpired(const std::string &sUserName)
{
    time_t tAccountExpirationDate = accountExpirationDate(sUserName);
    if (!tAccountExpirationDate) return false;
    return tAccountExpirationDate<time(nullptr);
}

std::set<std::string> Manager::accountUsableAttribs(const std::string &sUserName)
{
    std::set<std::string> x;
    Threads::Sync::Lock_RD lock(mutex);
    // Take attribs from the account
    for (const std::string & attrib : accountDirectAttribs(sUserName,false))
        x.insert(attrib);

    // Take the attribs from the belonging groups
    for (const std::string & groupName : accountGroups(sUserName,false))
    {
        for (const std::string & attrib : groupAttribs(groupName,false))
            x.insert(attrib);
    }
    return x;
}

bool Manager::superUserAccountExist()
{
    auto accounts = accountsList();
    for (const std::string & account : accounts)
    {
        if (isAccountSuperUser(account))
            return true;
    }
    return false;
}

bool Manager::accountValidateAttribute(const std::string &sUserName, const std::string &attribName)
{
    Threads::Sync::Lock_RD lock(mutex);
    if (accountValidateDirectAttribute(sUserName,attribName))
    {
        return true;
    }
    for (const std::string & groupName : accountGroups(sUserName,false))
    {
        if (groupValidateAttribute(groupName, attribName,false))
        {
            return true;
        }
    }
    return false;
}
