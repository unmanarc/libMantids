#include "manager.h"

#include <cx2_thr_mutex/lock_shared.h>
#include <cx2_hlp_functions/random.h>

using namespace CX2::Authentication;


Manager::Manager()
{
    bAuthPolicyMaxTries = 4;
    bAuthPolicyAbandonedAccountExpirationSeconds = 180 * 24 * 3600; // 6 Months..
}

Manager::~Manager()
{
}

bool Manager::initAccounts()
{
    // create the default account.
    Secret secretData;
    secretData.forceExpiration = true;
    secretData.hash = CX2::Helpers::Random::createRandomString(16);

    return accountAdd("admin",  // UserName
                      secretData, // Secret Info
                      { "", // Given Name
                        "", // Last Name
                        "", // Email
                        "Autogenerated Superuser Account", // Description
                        "" // Extra Data
                      },
                      0, // Expiration (don't expire)
                      { true, // enabled
                        true,// confirmed
                        true // superuser
                      }
                      );
}

Reason Manager::authenticate(const std::string &appName, const sClientDetails &clientDetails, const std::string &sAccountName, const std::string &incommingPassword, uint32_t passIndex, Mode authMode, const std::string &challengeSalt, std::map<uint32_t,std::string> *stAccountPassIndexesUsedForLogin)
{
    Reason ret = REASON_BAD_ACCOUNT;
    bool accountFound=false, indexFound=false;
    Secret pStoredSecretData;
    uint32_t _bAuthPolicyMaxTries=0;

    // If something changes in between,
    if (1)
    {
        Threads::Sync::Lock_RD lock(mutex);

        // Check if the user is enabled to authenticate in this APP:
        if (!applicationValidateAccount(appName,sAccountName))
            return REASON_BAD_ACCOUNT; // Account not available for this application.

        // Check if the retrieved secret
        pStoredSecretData = retrieveSecret(sAccountName,passIndex, &accountFound, &indexFound);
        _bAuthPolicyMaxTries = bAuthPolicyMaxTries;

        if (accountFound == false)
            ret = REASON_BAD_ACCOUNT;
        else if (indexFound == false)
            ret = REASON_PASSWORD_INDEX_NOTFOUND;
        else
        {
            time_t lastLogin = accountLastLogin(sAccountName);

            if      (!isAccountConfirmed(sAccountName))
                return REASON_UNCONFIRMED_ACCOUNT;

            else if (isAccountDisabled(sAccountName))
                return REASON_DISABLED_ACCOUNT;

            else if (isAccountExpired(sAccountName))
                return REASON_EXPIRED_ACCOUNT;

            else if (lastLogin+bAuthPolicyAbandonedAccountExpirationSeconds<time(nullptr))
                return REASON_EXPIRED_ACCOUNT;

            else
            {
                ret = validateStoredSecret(pStoredSecretData, incommingPassword, challengeSalt, authMode);

                // On successfull first login, give all pass indexes used for login...
                if ( IS_PASSWORD_AUTHENTICATED(ret) && stAccountPassIndexesUsedForLogin && passIndex == 0 )
                {
                    *stAccountPassIndexesUsedForLogin = accountPassIndexesUsedForLogin(sAccountName);

                    // If can't retrieve well the pass indexes used for login, return an authentication error for any valid idx 0 password (preventing error).
                    if (stAccountPassIndexesUsedForLogin->find(0xFFFFFFFF)!=stAccountPassIndexesUsedForLogin->end())
                        return REASON_INTERNAL_ERROR;
                }
            }
        }
    }

    // Register the change for max attempts...
    if ( !IS_PASSWORD_AUTHENTICATED( ret ) )
    {
        // Increment the counter and disable the account acording to the policy.
        if ( (pStoredSecretData.badAttempts + 1) >= _bAuthPolicyMaxTries )
        {
            // Disable the account...
            accountDisable(sAccountName,true);
        }
        else
        {
            incrementBadAttempts(sAccountName,passIndex);
        }
    }
    else
    {
        // Authenticated:
        updateLastLogin(sAccountName,passIndex,clientDetails);
        resetBadAttempts(sAccountName,passIndex);
    }


    return ret;
}

std::string Manager::genRandomConfirmationToken()
{
    return CX2::Helpers::Random::createRandomString(64);
}

uint32_t Manager::getBAuthPolicyMaxTries()
{
    Threads::Sync::Lock_RD lock(mutex);

    return bAuthPolicyMaxTries;
}

void Manager::setBAuthPolicyMaxTries(const uint32_t &value)
{
    Threads::Sync::Lock_RW lock(mutex);

    bAuthPolicyMaxTries = value;
}

Secret_PublicData Manager::accountSecretPublicData(const std::string &sAccountName, uint32_t passIndex)
{
    // protective-limited method.
    bool bAccountFound = false;
    bool bIndexFound = false;
    Secret pd = retrieveSecret(sAccountName, passIndex, &bAccountFound, &bIndexFound);
    Secret_PublicData pdb;

    if (bAccountFound && bIndexFound)
    {
        pdb = pd.getBasicData();
        pdb.description = passIndexDescription(passIndex);

        auto forlogin = passIndexesRequiredForLogin();
        if (forlogin.find(passIndex) != forlogin.end())
        {
            pdb.requiredAtLogin=true;
        }
        if ( (pdb.badAttempts + 1) >= bAuthPolicyMaxTries )
        {
            pdb.locked = true;
        }
    }

    return pdb;
}

std::map<uint32_t, Secret_PublicData> Manager::getAccountAllSecretsPublicData(const std::string &sAccountName)
{
    std::map<uint32_t, Secret_PublicData> r;

    // Get every pass required for login (even if not present)
    std::set<uint32_t> requiredForLogin = passIndexesRequiredForLogin();
    std::set<uint32_t> usedByAccount =  passIndexesUsedByAccount(sAccountName);

    std::set<uint32_t> combination;

    for (const auto & idxReqForLog : requiredForLogin)
        combination.insert(idxReqForLog);

    for (const auto & idxUsedByAcct : usedByAccount)
        combination.insert(idxUsedByAcct);

    for (const auto & idx: combination)
    {
        r[idx] = accountSecretPublicData(sAccountName,idx);
    }

    return r;

}

std::map<uint32_t,std::string> Manager::accountPassIndexesUsedForLogin(const std::string &sAccountName)
{
    std::map<uint32_t,std::string> r;
    std::set<uint32_t> requiredForLogin = passIndexesRequiredForLogin();

    if (requiredForLogin.empty())
    {
        // Weird... could even be a database error... add impossible's r.
        r[0xFFFFFFFF] = "";
        return r;
    }

    for (const auto & i : passIndexesUsedByAccount(sAccountName))
    {
        if (requiredForLogin.find(i)!=requiredForLogin.end())
            r[i] = passIndexDescription(i);
    }

    return r;
}

bool Manager::accountChangeAuthenticatedSecret(const std::string & appName, const std::string &sAccountName, uint32_t passIndex, const std::string &sCurrentPassword, const Secret &passwordData, const sClientDetails & clientInfo, Mode authMode, const std::string &challengeSalt)
{
    // Authenticate the current passIndex.
    auto i = authenticate(appName,clientInfo,sAccountName,sCurrentPassword,passIndex,authMode,challengeSalt);

    // If this pass index is not found for this user, make the authentication with the 0 (master password)
    if (i == REASON_PASSWORD_INDEX_NOTFOUND)
    {
        // > We want to define a new password index if not exist.
        i = authenticate(appName,clientInfo,sAccountName,sCurrentPassword,0,authMode,challengeSalt);
        // Now i contains AUTHENTICATED if the password was validated agains index 0.
    }

    // TODO: ask/validate for all required authentication items, not only the master password.

    // Now take the authentication and add/change the secret
    if ( IS_PASSWORD_AUTHENTICATED(i) )
    {
        // Change the requested index.
        return accountChangeSecret(sAccountName,passwordData,passIndex);
    }

    return false;
}

bool Manager::isAccountExpired(const std::string &sAccountName)
{
    time_t tAccountExpirationDate = accountExpirationDate(sAccountName);
    if (!tAccountExpirationDate) return false;
    return tAccountExpirationDate<time(nullptr);
}

std::set<sApplicationAttrib> Manager::accountUsableAttribs(const std::string &sAccountName)
{
    std::set<sApplicationAttrib> x;
    Threads::Sync::Lock_RD lock(mutex);
    // Take attribs from the account
    for (const sApplicationAttrib & attrib : accountDirectAttribs(sAccountName,false))
        x.insert(attrib);

    // Take the attribs from the belonging groups
    for (const std::string & groupName : accountGroups(sAccountName,false))
    {
        for (const sApplicationAttrib & attrib : groupAttribs(groupName,false))
            x.insert(attrib);
    }
    return x;
}

bool Manager::superUserAccountExist()
{
    auto accounts = accountsList();
    for (const std::string & account : accounts)
    {
        if (isAccountSuperUser(account))
            return true;
    }
    return false;
}

bool Manager::accountValidateAttribute(const std::string &sAccountName, const sApplicationAttrib & applicationAttrib)
{
    Threads::Sync::Lock_RD lock(mutex);
    if (accountValidateDirectAttribute(sAccountName,applicationAttrib))
    {
        return true;
    }
    for (const std::string & groupName : accountGroups(sAccountName,false))
    {
        if (groupValidateAttribute(groupName, applicationAttrib,false))
        {
            return true;
        }
    }
    return false;
}
